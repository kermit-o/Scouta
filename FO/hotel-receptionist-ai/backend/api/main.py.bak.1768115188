"""
API principal del recepcionista automatizado
"""
from __future__ import annotations

import json
import logging
import os
import re
import sys
import uuid
from contextlib import asynccontextmanager
from datetime import date, datetime
from typing import Dict, Optional, Tuple

import asyncpg
from dotenv import load_dotenv
from fastapi import FastAPI, HTTPException, Request, Response
from fastapi.middleware.cors import CORSMiddleware
from twilio.request_validator import RequestValidator

# Add backend directory to path (optional for future imports)
sys.path.append(os.path.dirname(os.path.dirname(os.path.abspath(__file__))))

# Load environment variables
load_dotenv()

# Logging
logging.basicConfig(
    level=logging.INFO,
    format="%(asctime)s - %(name)s - %(levelname)s - %(message)s",
)
logger = logging.getLogger(__name__)


# ========== CONFIG ==========
class Settings:
    """Application settings"""

    DATABASE_URL = os.getenv(
        "DATABASE_URL",
        "postgresql+asyncpg://hotel_admin:hotel_password@postgres:5432/hotel_db",
    )
    ENVIRONMENT = os.getenv("ENVIRONMENT", "development")

    TWILIO_ACCOUNT_SID = os.getenv("TWILIO_ACCOUNT_SID")
    TWILIO_AUTH_TOKEN = os.getenv("TWILIO_AUTH_TOKEN")
    TWILIO_PHONE_NUMBER = os.getenv("TWILIO_PHONE_NUMBER")


settings = Settings()


# ========== HELPERS ==========
def _db_dsn() -> str:
    """asyncpg does not accept '+asyncpg' in the DSN."""
    return settings.DATABASE_URL.replace("+asyncpg", "")


def normalize_phone(raw: str) -> str:
    """Normalize phone number."""
    if not raw:
        return "Desconocido"
    s = raw.strip()
    compact = s.replace(" ", "")
    if compact and not compact.startswith("+") and compact.isdigit():
        return f"+{compact}"
    return s


def detect_channel(from_value: str) -> str:
    """Detect channel (sms/whatsapp)."""
    if (from_value or "").startswith("whatsapp:"):
        return "whatsapp"
    return "sms"


def normalize_from(from_value: str) -> str:
    """Normalize Twilio From field (handles whatsapp:+...)."""
    s = (from_value or "").strip()
    if s.startswith("whatsapp:"):
        s = s.replace("whatsapp:", "", 1).strip()
    if s and not s.startswith("+") and s.replace(" ", "").isdigit():
        s = f"+{s.replace(' ', '')}"
    return s or "Desconocido"


def _safe_json_obj(value) -> dict:
    """
    Ensure a dict-like JSON object.
    Postgres JSONB sometimes comes back as str depending on driver/codec.
    """
    if value is None:
        return {}
    if isinstance(value, dict):
        return value
    if isinstance(value, str):
        try:
            parsed = json.loads(value)
            return parsed if isinstance(parsed, dict) else {}
        except Exception:
            return {}
    # Any other type -> fallback
    return {}


def build_public_url(request: Request, path: str) -> str:
    """
    Build absolute public URL for Twilio callbacks.
    Priority:
    1) WEBHOOK_BASE_URL (recommended in Codespaces/production)
    2) request.base_url (local/proxy)
    """
    base = os.getenv("WEBHOOK_BASE_URL", "").strip().rstrip("/")
    if base:
        return f"{base}{path}"
    return f"{str(request.base_url).rstrip('/')}{path}"


async def verify_twilio_request(request: Request) -> None:
    """
    Validate Twilio signature ONLY if TWILIO_VALIDATE_SIGNATURES=true.
    Dev: false -> allows curl/manual testing.
    Prod: true -> requires valid signature.
    """
    validate = (
        os.getenv("TWILIO_VALIDATE_SIGNATURES", "false").strip().lower()
        in ("1", "true", "yes")
    )

    if not validate:
        logger.warning(
            "Twilio signature validation disabled (TWILIO_VALIDATE_SIGNATURES=false)"
        )
        return

    if not settings.TWILIO_AUTH_TOKEN:
        raise HTTPException(
            status_code=500,
            detail="TWILIO_AUTH_TOKEN missing but validation is enabled",
        )

    signature = request.headers.get("X-Twilio-Signature", "")
    if not signature:
        raise HTTPException(status_code=403, detail="Missing Twilio signature header")

    form = await request.form()
    params: Dict[str, str] = dict(form)

    validator = RequestValidator(settings.TWILIO_AUTH_TOKEN)
    url_for_validation = build_public_url(request, request.url.path)

    ok = validator.validate(url_for_validation, params, signature)
    if not ok:
        logger.warning("Invalid Twilio signature. url=%s", url_for_validation)
        raise HTTPException(status_code=403, detail="Invalid Twilio signature")


def parse_dates(text: str) -> Tuple[Optional[date], Optional[date]]:
    """
    Extract 2 dates from text.
    Supports:
      - YYYY-MM-DD
      - DD/MM/YYYY
      - DD-MM-YYYY
    """
    t = (text or "").strip()

    iso = re.findall(r"\b(\d{4})-(\d{2})-(\d{2})\b", t)
    dmy = re.findall(r"\b(\d{1,2})[\/\-](\d{1,2})[\/\-](\d{4})\b", t)

    found: list[date] = []

    for y, m, d in iso:
        try:
            found.append(date(int(y), int(m), int(d)))
        except ValueError:
            pass

    for d, m, y in dmy:
        try:
            found.append(date(int(y), int(m), int(d)))
        except ValueError:
            pass

    # Dedup keeping order
    uniq: list[date] = []
    for x in found:
        if x not in uniq:
            uniq.append(x)

    if len(uniq) >= 2:
        return uniq[0], uniq[1]
    if len(uniq) == 1:
        return uniq[0], None
    return None, None


def detect_intent(text: str) -> str:
    t = (text or "").lower()
    if any(k in t for k in ["reserva", "reservar", "habitacion", "habitaci√≥n", "booking"]):
        return "reservation"
    if any(k in t for k in ["precio", "tarifa", "cuanto", "cu√°nto", "coste", "costo"]):
        return "pricing"
    if any(k in t for k in ["check-in", "check in", "checkin"]):
        return "check_in"
    if any(k in t for k in ["check-out", "check out", "checkout"]):
        return "check_out"
    if any(k in t for k in ["cancel", "cancelar", "anular"]):
        return "cancel"
    return "unknown"


# ========== DB (CALLS) ==========
async def log_call(
    caller_number: str,
    intent_detected: Optional[str],
    resolution_status: Optional[str],
    call_duration: Optional[int] = None,
    recording_url: Optional[str] = None,
) -> None:
    """Insert a record into call_logs."""
    try:
        conn = await asyncpg.connect(_db_dsn())
        await conn.execute(
            """
            INSERT INTO call_logs (
                id, caller_number, call_duration, intent_detected, resolution_status, recording_url
            ) VALUES ($1, $2, $3, $4, $5, $6)
            """,
            str(uuid.uuid4()),
            caller_number,
            call_duration,
            intent_detected,
            resolution_status,
            recording_url,
        )
        await conn.close()
        logger.info(
            "‚úÖ call_logs inserted: caller=%s intent=%s status=%s",
            caller_number,
            intent_detected,
            resolution_status,
        )
    except Exception:
        logger.exception("‚ùå Failed to insert call_logs")


# ========== DB (MESSAGING) ==========
async def upsert_thread(phone_number: str, channel: str) -> dict:
    conn = await asyncpg.connect(_db_dsn())
    row = await conn.fetchrow(
        """
        INSERT INTO message_threads (id, phone_number, channel)
        VALUES ($1, $2, $3)
        ON CONFLICT (phone_number, channel)
        DO UPDATE SET updated_at = CURRENT_TIMESTAMP
        RETURNING id, phone_number, channel, state, context, last_intent
        """,
        str(uuid.uuid4()),
        phone_number,
        channel,
    )
    await conn.close()

    data = dict(row)
    data["context"] = _safe_json_obj(data.get("context"))
    return data


async def update_thread(
    phone_number: str,
    channel: str,
    state: str,
    context: dict,
    last_intent: Optional[str],
) -> None:
    conn = await asyncpg.connect(_db_dsn())
    await conn.execute(
        """
        UPDATE message_threads
        SET state=$1,
            context=$2::jsonb,
            last_intent=$3,
            last_message_at=CURRENT_TIMESTAMP,
            updated_at=CURRENT_TIMESTAMP
        WHERE phone_number=$4 AND channel=$5
        """,
        state,
        json.dumps(context),
        last_intent,
        phone_number,
        channel,
    )
    await conn.close()


async def log_message(
    phone_number: str,
    channel: str,
    direction: str,
    body: str,
    sid: Optional[str],
) -> None:
    conn = await asyncpg.connect(_db_dsn())
    await conn.execute(
        """
        INSERT INTO message_logs (id, phone_number, channel, direction, body, twilio_message_sid)
        VALUES ($1, $2, $3, $4, $5, $6)
        """,
        str(uuid.uuid4()),
        phone_number,
        channel,
        direction,
        body,
        sid,
    )
    await conn.close()


# ========== TWILIO SIMPLE SERVICE ==========
class TwilioSimpleService:
    """Simplified Twilio service"""

    def __init__(self) -> None:
        self.account_sid = settings.TWILIO_ACCOUNT_SID
        self.auth_token = settings.TWILIO_AUTH_TOKEN
        self.phone_number = settings.TWILIO_PHONE_NUMBER
        self.is_configured = bool(self.account_sid and self.auth_token)

        if self.is_configured:
            logger.info("‚úÖ Twilio service initialized")
        else:
            logger.warning("‚ö†Ô∏è Twilio not configured")

    def send_sms(self, to_number: str, message: str) -> dict:
        if settings.ENVIRONMENT == "development":
            logger.info("üì± [DEV] SMS simulado a %s: %s...", to_number, message[:50])
            return {
                "success": True,
                "sid": f"dev_sms_{to_number[-8:]}",
                "status": "sent",
                "to": to_number,
                "message": message,
            }
        return {"success": False, "error": "Twilio no configurado para producci√≥n"}

    def make_call(self, to_number: str, message: str) -> dict:
        if settings.ENVIRONMENT == "development":
            logger.info("üìû [DEV] Llamada simulada a %s", to_number)
            return {
                "success": True,
                "sid": f"dev_call_{to_number[-8:]}",
                "status": "queued",
                "to": to_number,
            }
        return {"success": False, "error": "Twilio no configurado para producci√≥n"}

    def get_phone_numbers(self) -> list:
        if self.is_configured:
            return [
                {
                    "phone_number": self.phone_number or "+15005550006",
                    "friendly_name": "N√∫mero de prueba Twilio",
                    "sid": "PN_test123",
                }
            ]
        return []


twilio_service = TwilioSimpleService()


# ========== LIFESPAN & APP ==========
@asynccontextmanager
async def lifespan(app: FastAPI):
    logger.info("üöÄ Iniciando Hotel Receptionist AI")
    yield
    logger.info("üëã Apagando Hotel Receptionist AI")


app = FastAPI(
    title="Hotel Receptionist AI API",
    description="API para el recepcionista automatizado del hotel",
    version="1.0.0",
    lifespan=lifespan,
)

app.add_middleware(
    CORSMiddleware,
    allow_origins=["*"],
    allow_credentials=True,
    allow_methods=["*"],
    allow_headers=["*"],
)


# ========== BASIC ENDPOINTS ==========
@app.get("/")
async def root():
    return {
        "status": "online",
        "service": "Hotel Receptionist AI",
        "version": "1.0.0",
        "endpoints": {
            "health": "/health",
            "docs": "/docs",
            "twilio_status": "/api/v1/twilio/status",
            "reservations": "/api/v1/reservations",
            "webhook_call": "/api/v1/webhooks/twilio/incoming",
            "webhook_messages": "/api/v1/webhooks/twilio/messages",
        },
    }


@app.get("/health")
async def health_check():
    return {
        "status": "healthy",
        "timestamp": datetime.now().isoformat(),
        "components": {
            "api": "operational",
            "database": "connected",
            "ai_services": "ready",
        },
    }


# ========== TWILIO WEBHOOKS (CALLS) ==========
@app.post("/api/v1/webhooks/twilio/incoming")
async def handle_incoming_call(request: Request):
    """Handle Twilio incoming calls (IVR)"""
    try:
        await verify_twilio_request(request)

        form_data = await request.form()
        caller_raw = form_data.get("From", "Desconocido")
        caller = normalize_phone(caller_raw)

        logger.info("üìû Llamada entrante de: %s", caller)

        await log_call(
            caller_number=caller,
            intent_detected="ivr_entry",
            resolution_status="menu_presented",
        )

        menu_url = build_public_url(request, "/api/v1/webhooks/twilio/menu")

        xml_response = f"""<?xml version="1.0" encoding="UTF-8"?>
<Response>
    <Say language="es-ES" voice="alice">
        Gracias por llamar al Hotel Para√≠so.
        Para hacer una reserva, presione 1.
        Para consultar una reserva existente, presione 2.
        Para informaci√≥n del hotel, presione 3.
        Para hablar con un recepcionista, presione 0.
    </Say>
    <Gather numDigits="1" action="{menu_url}" method="POST" timeout="5"></Gather>
    <Say language="es-ES" voice="alice">
        No recibimos su respuesta. Por favor llame nuevamente.
    </Say>
</Response>"""

        return Response(content=xml_response, media_type="application/xml")

    except HTTPException:
        raise
    except Exception:
        logger.exception("Error procesando llamada")
        raise HTTPException(status_code=500, detail="Error interno del servidor")


@app.post("/api/v1/webhooks/twilio/menu")
async def handle_menu_selection(request: Request):
    """Handle IVR menu selection"""
    try:
        await verify_twilio_request(request)

        form_data = await request.form()
        digit = (form_data.get("Digits", "") or "").strip()
        caller = normalize_phone(form_data.get("From", "Desconocido"))

        logger.info("Selecci√≥n del men√∫: %s (caller=%s)", digit, caller)

        if digit == "1":
            intent = "reservation"
            status = "automated"
            response_message = (
                "Para reservas, env√≠e por WhatsApp: fechas (entrada/salida) y n√∫mero de personas. "
                "Si prefiere, tambi√©n puede SMS."
            )
        elif digit == "2":
            intent = "reservation_lookup"
            status = "needs_followup"
            response_message = (
                "Para consultar su reserva, env√≠e su n√∫mero de reserva por WhatsApp o SMS."
            )
        elif digit == "3":
            intent = "hotel_info"
            status = "automated"
            response_message = (
                "Nuestro horario de check-in es a las 15:00 y check-out a las 12:00. "
                "Tenemos WiFi gratuito, piscina, restaurante y spa."
            )
        elif digit == "0":
            intent = "human_transfer"
            status = "transferred"
            response_message = "Transfiriendo con un recepcionista. Por favor espere."
        else:
            intent = "invalid"
            status = "invalid_choice"
            response_message = "Opci√≥n no v√°lida. Por favor intente nuevamente."

        await log_call(
            caller_number=caller,
            intent_detected=intent,
            resolution_status=status,
        )

        xml_response = f"""<?xml version="1.0" encoding="UTF-8"?>
<Response>
    <Say language="es-ES" voice="alice">
        {response_message}
    </Say>
</Response>"""

        return Response(content=xml_response, media_type="application/xml")

    except HTTPException:
        raise
    except Exception:
        logger.exception("Error procesando selecci√≥n de men√∫")
        raise HTTPException(status_code=500, detail="Error interno del servidor")


# ========== TWILIO WEBHOOKS (MESSAGES) ==========
@app.post("/api/v1/webhooks/twilio/messages")
async def handle_incoming_message(request: Request):
    """
    Webhook for incoming SMS/WhatsApp from Twilio.
    Responds with TwiML <Message>.
    """
    await verify_twilio_request(request)

    form = await request.form()
    from_raw = form.get("From", "")
    body = (form.get("Body", "") or "").strip()
    msg_sid = form.get("MessageSid") or form.get("SmsMessageSid")

    channel = detect_channel(from_raw)
    phone = normalize_from(from_raw)

    logger.info("üí¨ Message inbound (%s) from=%s body=%s", channel, phone, body[:120])

    # Log inbound
    await log_message(phone, channel, "inbound", body, msg_sid)

    # Thread/state
    thread = await upsert_thread(phone, channel)
    state = thread.get("state") or "idle"
    context = _safe_json_obj(thread.get("context"))
    intent = detect_intent(body)

    reply = ""

    # Commands
    if body.lower() in ("reset", "reiniciar", "start", "inicio"):
        await update_thread(phone, channel, "idle", {}, "reset")
        reply = (
            "Perfecto. Empecemos de nuevo. "
            "¬øQuieres hacer una reserva? Indica fechas (check-in y check-out) y n√∫mero de personas."
        )
        await log_message(phone, channel, "outbound", reply, None)
        return Response(
            content=f'<?xml version="1.0" encoding="UTF-8"?><Response><Message>{reply}</Message></Response>',
            media_type="application/xml",
        )

    if body.lower() == "confirmar":
        if (not context) or (not context.get("check_in")) or (not context.get("check_out")) or (
            not context.get("pax")
        ) or (not context.get("room_type")):
            reply = (
                "Para confirmar necesito: fechas, personas y tipo de habitaci√≥n. "
                "Si quieres empezar de nuevo escribe RESET."
            )
        else:
            context["confirmed_at"] = datetime.now().isoformat()
            await update_thread(phone, channel, "confirmed", context, "reservation")
            reply = (
                "Reserva pre-confirmada. "
                "Un recepcionista te contactar√° en breve para finalizar (nombre y email si aplica)."
            )

        await log_message(phone, channel, "outbound", reply, None)
        return Response(
            content=f'<?xml version="1.0" encoding="UTF-8"?><Response><Message>{reply}</Message></Response>',
            media_type="application/xml",
        )

    # Reservation state machine
    if state == "idle":
        if intent == "reservation":
            await update_thread(phone, channel, "awaiting_dates", {}, "reservation")
            reply = (
                "Perfecto. Para la reserva, env√≠ame 2 fechas:\n"
                "- Check-in y check-out (ej: 2026-02-10 y 2026-02-14)\n"
                "o (10/02/2026 y 14/02/2026)."
            )
        else:
            reply = (
                "Hola. Puedo ayudarte con reservas e informaci√≥n.\n"
                "Si quieres reservar, escribe: 'Quiero reservar' y dime fechas y personas."
            )

    elif state == "awaiting_dates":
        d1, d2 = parse_dates(body)
        if d1 and d2:
            if d2 <= d1:
                reply = (
                    "Las fechas no parecen correctas (check-out debe ser posterior al check-in). "
                    "Env√≠ame 2 fechas v√°lidas."
                )
            else:
                context = {"check_in": d1.isoformat(), "check_out": d2.isoformat()}
                await update_thread(phone, channel, "awaiting_pax", context, "reservation")
                reply = "Perfecto. ¬øPara cu√°ntas personas es la reserva?"
        else:
            reply = (
                "No pude leer 2 fechas. Env√≠ame check-in y check-out "
                "(ej: 2026-02-10 y 2026-02-14)."
            )

    elif state == "awaiting_pax":
        m = re.search(r"\b(\d{1,2})\b", body)
        if not m:
            reply = "No entend√≠ el n√∫mero de personas. Responde solo con un n√∫mero (ej: 2)."
        else:
            pax = int(m.group(1))
            if pax < 1 or pax > 8:
                reply = "Indica un n√∫mero de personas v√°lido (1 a 8)."
            else:
                # context is guaranteed dict here
                context["pax"] = pax

                availability = await check_availability(
                    check_in=context.get("check_in"),
                    check_out=context.get("check_out"),
                    room_type=None,
                )
                room_types = availability.get("room_types", {})

                options = []
                if "standard" in room_types:
                    options.append(("1", "Est√°ndar", room_types["standard"]))
                if "deluxe" in room_types:
                    options.append(("2", "Deluxe", room_types["deluxe"]))
                if "suite" in room_types:
                    options.append(("3", "Suite", room_types["suite"]))

                context["room_options"] = {
                    code: {
                        "key": label.lower(),
                        "label": label,
                        "price": meta.get("price"),
                        "available": meta.get("available"),
                    }
                    for code, label, meta in options
                }

                await update_thread(
                    phone, channel, "awaiting_room_type", context, "reservation"
                )

                lines = ["Perfecto. Opciones disponibles:"]
                for code, label, meta in options:
                    lines.append(
                        f"{code}) {label} ‚Äî {meta.get('price')}‚Ç¨/noche (disp: {meta.get('available')})"
                    )
                lines.append("")
                lines.append("Responde con 1, 2 o 3 para elegir tipo de habitaci√≥n.")
                reply = "\n".join(lines)

    elif state == "awaiting_room_type":
        choice = body.strip().lower()
        room_options = _safe_json_obj((context or {}).get("room_options"))

        selected = None
        if choice in room_options:
            selected = room_options[choice]
        else:
            normalized = (
                choice.replace("√°", "a")
                .replace("√©", "e")
                .replace("√≠", "i")
                .replace("√≥", "o")
                .replace("√∫", "u")
            )
            for _, v in room_options.items():
                key = (
                    (v.get("key") or "")
                    .replace("√°", "a")
                    .replace("√©", "e")
                    .replace("√≠", "i")
                    .replace("√≥", "o")
                    .replace("√∫", "u")
                )
                label = (v.get("label") or "").lower()
                if normalized in (key, label):
                    selected = v
                    break

        if not selected:
            reply = "No entend√≠ tu elecci√≥n. Responde con 1, 2 o 3."
        else:
            context["room_type"] = selected.get("label")
            await update_thread(phone, channel, "done", context, "reservation")

            reply = (
                "Perfecto. Resumen final:\n"
                f"- Check-in: {context.get('check_in')}\n"
                f"- Check-out: {context.get('check_out')}\n"
                f"- Personas: {context.get('pax')}\n"
                f"- Tipo: {context.get('room_type')} ({selected.get('price')}‚Ç¨/noche)\n\n"
                "Para confirmar, responde: CONFIRMAR.\n"
                "Para reiniciar, escribe: RESET."
            )

    else:
        reply = (
            "Estoy contigo. Si quieres una nueva reserva escribe: RESET. "
            "Si quieres info, dime qu√© necesitas."
        )

    # Log outbound
    await log_message(phone, channel, "outbound", reply, None)

    # TwiML reply
    xml = f'<?xml version="1.0" encoding="UTF-8"?><Response><Message>{reply}</Message></Response>'
    return Response(content=xml, media_type="application/xml")


# ========== RESERVATIONS ==========
@app.get("/api/v1/reservations")
async def get_reservations():
    return {"reservations": [], "count": 0, "message": "Endpoint en desarrollo"}


@app.post("/api/v1/reservations")
async def create_reservation():
    return {"message": "Reserva creada exitosamente", "reservation_id": "test-123", "status": "confirmed"}


@app.get("/api/v1/reservations/availability")
async def check_availability(
    check_in: str = "2024-01-10",
    check_out: str = "2024-01-15",
    room_type: Optional[str] = None,
):
    return {
        "check_in": check_in,
        "check_out": check_out,
        "available": True,
        "room_types": {
            "standard": {"available": 5, "price": 89.99},
            "deluxe": {"available": 3, "price": 149.99},
            "suite": {"available": 1, "price": 249.99},
        },
    }


# ========== METRICS ==========
@app.get("/api/v1/metrics/calls")
async def get_call_metrics():
    return {
        "total_calls_today": 24,
        "avg_call_duration": "2:45",
        "automation_rate": "85%",
        "common_intents": ["reserva", "informaci√≥n", "check-in"],
    }


@app.get("/api/v1/metrics/system")
async def get_system_metrics():
    return {
        "status": "healthy",
        "uptime": "24 hours",
        "database_connections": 5,
        "last_backup": datetime.now().isoformat(),
    }


# ========== DB STATS ==========
@app.get("/api/v1/stats/database")
async def get_database_stats():
    """Fetch real database stats"""
    try:
        conn = await asyncpg.connect(_db_dsn())

        total_guests = await conn.fetchval("SELECT COUNT(*) FROM guests")
        total_reservations = await conn.fetchval("SELECT COUNT(*) FROM reservations")
        total_call_logs = await conn.fetchval("SELECT COUNT(*) FROM call_logs")
        active_reservations = await conn.fetchval(
            "SELECT COUNT(*) FROM reservations WHERE status IN ('confirmed', 'checked_in')"
        )

        await conn.close()

        return {
            "total_guests": total_guests,
            "total_reservations": total_reservations,
            "active_reservations": active_reservations,
            "total_call_logs": total_call_logs,
            "last_updated": "just now",
        }

    except Exception as e:
        logger.error("Error obteniendo estad√≠sticas: %s", e)
        return {
            "total_guests": 10,
            "total_reservations": 8,
            "active_reservations": 6,
            "total_call_logs": 15,
            "last_updated": "cached",
            "error": str(e),
        }


# ========== RECENT CALLS ==========
@app.get("/api/v1/calls/recent")
async def get_recent_calls(limit: int = 10):
    """Fetch recent calls"""
    try:
        conn = await asyncpg.connect(_db_dsn())
        calls = await conn.fetch(
            """
            SELECT caller_number, call_duration, intent_detected, resolution_status, created_at
            FROM call_logs
            ORDER BY created_at DESC
            LIMIT $1
            """,
            limit,
        )
        await conn.close()

        return {
            "calls": [
                {
                    "caller_number": call["caller_number"],
                    "duration_seconds": call["call_duration"],
                    "intent": call["intent_detected"],
                    "status": call["resolution_status"],
                    "time": call["created_at"].isoformat() if call["created_at"] else None,
                }
                for call in calls
            ]
        }

    except Exception as e:
        logger.error("Error obteniendo llamadas recientes: %s", e)
        return {
            "calls": [
                {
                    "caller_number": "+34600123456",
                    "duration_seconds": 145,
                    "intent": "reserva",
                    "status": "automated",
                    "time": datetime.now().isoformat(),
                },
                {
                    "caller_number": "+34600234567",
                    "duration_seconds": 230,
                    "intent": "informaci√≥n",
                    "status": "transferred",
                    "time": datetime.now().isoformat(),
                },
            ],
            "error": str(e),
        }


# ========== TWILIO ENDPOINTS ==========
@app.get("/api/v1/twilio/status")
async def get_twilio_status():
    return {
        "configured": twilio_service.is_configured,
        "has_credentials": bool(twilio_service.account_sid and twilio_service.auth_token),
        "phone_number": twilio_service.phone_number,
        "message": (
            "Configure TWILIO_ACCOUNT_SID, TWILIO_AUTH_TOKEN, and TWILIO_PHONE_NUMBER in .env"
            if not twilio_service.is_configured
            else "Twilio est√° configurado correctamente"
        ),
        "environment": settings.ENVIRONMENT,
    }


@app.get("/api/v1/twilio/numbers")
async def get_twilio_numbers():
    if not twilio_service.is_configured:
        raise HTTPException(status_code=400, detail="Twilio no est√° configurado")

    numbers = twilio_service.get_phone_numbers()
    return {"numbers": numbers, "count": len(numbers)}


@app.post("/api/v1/twilio/send-sms")
async def send_sms_via_twilio(to: str, message: str):
    if not twilio_service.is_configured:
        raise HTTPException(status_code=400, detail="Twilio no est√° configurado")

    result = twilio_service.send_sms(to, message)
    if result["success"]:
        return {"success": True, "data": result}
    raise HTTPException(status_code=500, detail=result.get("error", "Error desconocido"))


@app.post("/api/v1/twilio/make-call")
async def make_twilio_call(to: str):
    if not twilio_service.is_configured:
        raise HTTPException(status_code=400, detail="Twilio no est√° configurado")

    message = "Hola, esta es una llamada de prueba del Hotel Receptionist AI. Gracias por tu inter√©s."
    result = twilio_service.make_call(to, message)

    if result["success"]:
        return {"success": True, "data": result}
    raise HTTPException(status_code=500, detail=result.get("error", "Error desconocido"))


@app.get("/api/v1/webhooks/twilio/outgoing-call")
async def handle_outgoing_call():
    xml_response = """<?xml version="1.0" encoding="UTF-8"?>
<Response>
    <Say language="es-ES" voice="alice">
        Hola, esta es una llamada autom√°tica del Hotel Para√≠so.
        Gracias por tu inter√©s en nuestros servicios.
        Para m√°s informaci√≥n, visita nuestro sitio web hotelparaiso.com
        ¬°Que tengas un excelente d√≠a!
    </Say>
</Response>"""
    return Response(content=xml_response, media_type="application/xml")


if __name__ == "__main__":
    import uvicorn

    uvicorn.run(
        "main:app",
        host="0.0.0.0",
        port=8000,
        reload=True,
        log_level="info",
    )
