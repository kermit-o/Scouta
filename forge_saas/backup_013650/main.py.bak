import os, uuid, threading, time, logging
from typing import Optional, Dict, Any
from datetime import datetime, timedelta

from fastapi import FastAPI, Depends, HTTPException, Body
from fastapi.middleware.cors import CORSMiddleware
from fastapi.responses import JSONResponse
from fastapi.exceptions import RequestValidationError
from fastapi.encoders import jsonable_encoder

from sqlalchemy import create_engine
from sqlalchemy.orm import sessionmaker, Session
from sqlalchemy.exc import IntegrityError, ProgrammingError

from app.models.project import Base, Project

# ---------- DB ----------
DATABASE_URL = os.getenv("DATABASE_URL", "postgresql+psycopg2://forge:forge@postgres:5432/forge")
engine = create_engine(DATABASE_URL, pool_pre_ping=True, future=True)
SessionLocal = sessionmaker(autocommit=False, autoflush=False, bind=engine)
Base.metadata.create_all(bind=engine)

def get_db():
    db: Session = SessionLocal()
    try:
        yield db
    finally:
        db.close()

# ---------- App ----------
app = FastAPI(title="Forge Backend", openapi_url="/api/openapi.json", docs_url="/api/docs")

origins = [
    os.getenv("CORS_ORIGIN", "*"),
    "http://localhost",
    "http://localhost:8501",
    "http://127.0.0.1:8501",
    "http://ui:8501",
]
app.add_middleware(
    CORSMiddleware,
    allow_origins=origins, allow_methods=["*"], allow_headers=["*"], allow_credentials=True,
)

# ---------- Error handlers ----------
@app.exception_handler(IntegrityError)
async def handle_integrity_error(request, exc: IntegrityError):
    return JSONResponse(status_code=422, content={
        "detail": "Database constraint error",
        "hint": str(getattr(exc, "orig", exc))
    })

@app.exception_handler(ProgrammingError)
async def handle_programming_error(request, exc: ProgrammingError):
    return JSONResponse(status_code=400, content={
        "detail": "Invalid database operation",
        "hint": str(getattr(exc, "orig", exc))
    })

@app.exception_handler(RequestValidationError)
async def handle_request_validation_error(request, exc: RequestValidationError):
    return JSONResponse(status_code=422, content={"detail": exc.errors()})

# ---------- In-memory progress ----------
_PROGRESS: Dict[str, Dict[str, Any]] = {}
_TTL = 60 * 30

def set_progress(job_id: str, percent: int, message: str):
    _PROGRESS[job_id] = {
        "job_id": job_id,
        "percent": max(0, min(100, percent)),
        "message": message,
        "updated_at": datetime.utcnow().isoformat() + "Z",
    }

def get_progress(job_id: str):
    return _PROGRESS.get(job_id, {"job_id": job_id, "percent": 0, "message": "unknown job"})

def _cleanup_loop():
    while True:
        now = datetime.utcnow()
        for k, v in list(_PROGRESS.items()):
            try:
                updated = datetime.fromisoformat(v["updated_at"].replace("Z", ""))
            except Exception:
                updated = now
            if (now - updated) > timedelta(seconds=_TTL):
                _PROGRESS.pop(k, None)
        time.sleep(30)

threading.Thread(target=_cleanup_loop, daemon=True).start()

# ---------- Routes ----------
@app.get("/api/health")
def health():
    return {"status": "ok"}

@app.get("/api/projects")
def list_projects(db: Session = Depends(get_db)):
    items = db.query(Project).filter(Project.is_deleted == False).order_by(Project.created_at.desc()).all()
    return jsonable_encoder(items)

@app.post("/api/projects", status_code=201)
def create_project(payload: Dict[str, Any] = Body(...), db: Session = Depends(get_db)):
    required = ["user_id", "project_name", "requirements"]
    missing = [k for k in required if not payload.get(k)]
    if missing:
        raise HTTPException(status_code=422, detail=f"Missing fields: {', '.join(missing)}")

    p = Project(
        user_id=payload["user_id"],
        project_name=payload["project_name"],
        requirements=payload["requirements"],
        status="pending",
        technology_stack=None,
        generated_plan=None,
    )
    db.add(p)
    db.flush()
    db.refresh(p)
    db.commit()
    return jsonable_encoder(p)

@app.get("/api/progress/{job_id}")
def progress(job_id: str):
    return get_progress(job_id)

def _plan_worker(job_id: str, project_id: str):
    db = SessionLocal()
    try:
        set_progress(job_id, 10, "Project created")

        proj = db.get(Project, project_id)
        if not proj:
            set_progress(job_id, 100, "Project not found")
            return

        set_progress(job_id, 25, "Analyzing requirements")
        time.sleep(0.4)

        tech = {
            "frontend": "Flutter",
            "backend": "Python + Flask",
            "db": "PostgreSQL",
            "realtime": "Socket.IO + Redis",
            "auth": "JWT",
        }
        set_progress(job_id, 40, "Drafting plan")
        time.sleep(0.4)
        plan = {
            "steps": [
                "Create Flask app skeleton",
                "Add SQLAlchemy models: User, Room, Task",
                "JWT auth endpoints",
                "CRUD /rooms /tasks",
                "Socket.IO notifications",
                "Flutter login + dashboard",
                "Dockerfiles & README",
                "Basic tests"
            ],
            "notes": "Auto-generated draft plan"
        }

        set_progress(job_id, 70, "Saving plan")
        proj.status = "planned"
        proj.technology_stack = tech
        proj.generated_plan = plan
        proj.updated_at = datetime.utcnow()
        db.add(proj)
        db.commit()

        set_progress(job_id, 90, "Plan saved. Finalizing")
        time.sleep(0.3)
        set_progress(job_id, 100, "Done")
    except Exception:
        logging.exception("Plan worker failed")
        set_progress(job_id, 100, "error: worker failed")
    finally:
        db.close()

@app.post("/api/projects/{project_id}/plan")
def plan_project(project_id: str, _: Optional[Dict[str, Any]] = Body(default=None), db: Session = Depends(get_db)):
    proj = db.get(Project, project_id)
    if not proj:
        raise HTTPException(status_code=404, detail="Project not found")

    job_id = str(uuid.uuid4())
    set_progress(job_id, 5, "Queued")

    t = threading.Thread(target=_plan_worker, args=(job_id, project_id), daemon=True)
    t.start()

    return {"job_id": job_id, "project_id": project_id, "started": True}
