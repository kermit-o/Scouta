from __future__ import annotations

import hashlib
import json
from datetime import datetime, timezone
from typing import Optional

from sqlalchemy.orm import Session

from app.models.comment import Comment
from app.models.post import Post
from app.models.agent_profile import AgentProfile
from app.services.deepseek_client import DeepSeekClient


def _sha256(s: str) -> str:
    return hashlib.sha256(s.encode("utf-8")).hexdigest()


def _now_utc():
    return datetime.now(timezone.utc)


def _must_json(system: str, user: str, ds: DeepSeekClient) -> dict:
    # Strong JSON-only instruction
    sys = system.strip() + "\n\nReturn ONLY valid JSON, no markdown, no code fences."
    out = ds.chat(system=sys, user=user)
    # Some providers still wrap; attempt strict parse
    try:
        return json.loads(out)
    except Exception:
        raise ValueError(f"Model did not return JSON (len={len(out)})")


def generate_comment_for_agent(
    db: Session,
    org_id: int,
    post_id: int,
    agent_id: int,
    parent_id: Optional[int] = None,
    stance: str = "neutral",
    source: str = "debate",
    publish: bool = True,
) -> Comment:
    post = db.query(Post).filter(Post.id == post_id, Post.org_id == org_id).first()
    if not post:
        raise ValueError("Post not found")

    agent = db.query(AgentProfile).filter(AgentProfile.id == agent_id, AgentProfile.org_id == org_id).first()
    if not agent or not getattr(agent, "is_enabled", True) or getattr(agent, "is_shadow_banned", False):
        raise ValueError("Agent not eligible")

    # context: last few comments in thread (if parent) else last few on post
    q = db.query(Comment).filter(Comment.org_id == org_id, Comment.post_id == post_id)
    if parent_id:
        q = q.filter(Comment.parent_id == parent_id)
    recent = q.order_by(Comment.id.desc()).limit(6).all()
    recent = list(reversed(recent))

    ctx_lines = []
    for c in recent:
        who = f"{c.author_type}:{c.author_agent_id or c.author_user_id or 'n/a'}"
        ctx_lines.append(f"- [{who}] {c.body_md[:500]}")
    ctx = "\n".join(ctx_lines) if ctx_lines else "(no prior comments)"

    ds = DeepSeekClient()

    system = f"""
You are an expert commenter.
Agent style: {getattr(agent, "style", "")}
Agent topics: {getattr(agent, "topics", "")}
Stance: {stance}

You must produce a single JSON object with:
- body_md: string (markdown allowed)
- summary: string (1 sentence)
"""

    user = f"""
POST_TITLE: {post.title}
POST_BODY_MD: {post.body_md[:4000]}

RECENT_COMMENTS:
{ctx}

Write ONE high-quality comment as this agent. Keep it focused and distinct.
"""

    data = _must_json(system=system, user=user, ds=ds)
    body_md = (data.get("body_md") or "").strip()
    if not body_md:
        raise ValueError("Empty body_md from model")

    h = _sha256(f"{org_id}|{post_id}|{agent_id}|{body_md}")
    # soft dedupe (do not require schema unique)
    exists = db.query(Comment).filter(Comment.org_id == org_id, Comment.post_id == post_id, Comment.content_hash == h).first()
    if exists:
        return exists

    status = "published" if publish else "draft"
    published_at = _now_utc() if publish else None

    row = Comment(
        org_id=org_id,
        post_id=post_id,
        parent_id=parent_id,
        author_user_id=None,
        author_agent_id=agent_id,
        author_type="agent",
        body_md=body_md,
        status=status,
        source=source,
        content_hash=h,
        published_at=published_at,
    )
    db.add(row)
    db.commit()
    db.refresh(row)
    return row
