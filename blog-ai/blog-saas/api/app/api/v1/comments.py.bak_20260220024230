from __future__ import annotations
import hashlib
from typing import Any, Optional
from fastapi import APIRouter, Depends, HTTPException, Header
from pydantic import BaseModel
from sqlalchemy.orm import Session

from app.core.db import get_db
from app.core.deps import get_current_user
from app.models.comment import Comment
from app.models.post import Post
from app.models.user import User

router = APIRouter(tags=["comments"])


class CommentIn(BaseModel):
    body: str
    parent_comment_id: Optional[int] = None


def _comment_dict(c: Comment, user: User | None = None) -> dict:
    return {
        "id": c.id,
        "post_id": c.post_id,
        "parent_comment_id": c.parent_comment_id,
        "author_type": c.author_type,
        "author_agent_id": c.author_agent_id,
        "author_user_id": c.author_user_id,
        "author_username": user.username if user else None,
        "author_display_name": user.display_name if user else None,
        "author_avatar_url": user.avatar_url if user else None,
        "status": c.status,
        "source": getattr(c, "source", None),
        "body": c.body,
        "created_at": str(c.created_at),
    }


@router.get("/orgs/{org_id}/posts/{post_id}/comments")
def list_comments(
    org_id: int,
    post_id: int,
    status: str | None = None,
    source: str | None = None,
    db: Session = Depends(get_db),
) -> dict[str, Any]:
    post = db.query(Post).filter(Post.org_id == org_id, Post.id == post_id).first()
    if not post:
        raise HTTPException(status_code=404, detail="Post not found")

    q = db.query(Comment).filter(Comment.org_id == org_id, Comment.post_id == post_id)
    if status:
        q = q.filter(Comment.status == status)
    if source:
        q = q.filter(Comment.source == source)
    rows = q.order_by(Comment.id.asc()).all()

    # Cargar usuarios para comentarios humanos
    user_ids = {c.author_user_id for c in rows if c.author_user_id}
    users = {u.id: u for u in db.query(User).filter(User.id.in_(user_ids)).all()} if user_ids else {}

    return {
        "post_id": post_id,
        "debate_status": getattr(post, "debate_status", "none"),
        "total": len(rows),
        "comments": [_comment_dict(c, users.get(c.author_user_id)) for c in rows],
    }


@router.post("/orgs/{org_id}/posts/{post_id}/comments")
def create_comment(
    org_id: int,
    post_id: int,
    payload: CommentIn,
    db: Session = Depends(get_db),
    user: User = Depends(get_current_user),
) -> dict:
    post = db.query(Post).filter(Post.org_id == org_id, Post.id == post_id).first()
    if not post:
        raise HTTPException(status_code=404, detail="Post not found")

    if not payload.body or len(payload.body.strip()) < 2:
        raise HTTPException(status_code=400, detail="Comment too short")

    if len(payload.body) > 2000:
        raise HTTPException(status_code=400, detail="Comment too long (max 2000 chars)")

    # Verificar parent existe si se especifica
    if payload.parent_comment_id:
        parent = db.query(Comment).filter(
            Comment.id == payload.parent_comment_id,
            Comment.post_id == post_id,
        ).one_or_none()
        if not parent:
            raise HTTPException(status_code=404, detail="Parent comment not found")

    body = payload.body.strip()
    comment_hash = hashlib.sha256(f"{user.id}:{post_id}:{body}".encode()).hexdigest()[:64]

    comment = Comment(
        org_id=org_id,
        post_id=post_id,
        parent_comment_id=payload.parent_comment_id,
        author_type="user",
        author_user_id=user.id,
        body=body,
        status="published",
        source="human",
        comment_hash=comment_hash,
    )
    db.add(comment)
    db.commit()
    db.refresh(comment)

    return _comment_dict(comment, user)
