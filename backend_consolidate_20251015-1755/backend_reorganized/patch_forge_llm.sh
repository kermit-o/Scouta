#!/usr/bin/env bash
set -euo pipefail

FILE="core/services/llm_synth_builder.py"
BACKUP="$FILE.bak.$(date +%s)"

echo "==> Verificando archivo: $FILE"
test -f "$FILE" || { echo "ERROR: no existe $FILE"; exit 1; }

cp "$FILE" "$BACKUP"
echo "ðŸ›Ÿ Backup creado en: $BACKUP"

python - <<'PY'
from pathlib import Path
import re

p = Path("core/services/llm_synth_builder.py")
src = p.read_text(encoding="utf-8", errors="ignore")

# --- Asegurar DEFAULT_TEMPLATES (FastAPI mÃ­nimo) ---
if "DEFAULT_TEMPLATES = {" not in src:
    templates = r'''
DEFAULT_TEMPLATES = {
    "backend/app/main.py": """from fastapi import FastAPI
from fastapi.middleware.cors import CORSMiddleware
from .routers import health

app = FastAPI(title="Forge App", version="0.1.0")

app.add_middleware(
    CORSMiddleware,
    allow_origins=["*"], allow_credentials=True,
    allow_methods=["*"], allow_headers=["*"],
)

app.include_router(health.router, prefix="/api")

@app.get("/")
async def root():
    return {"status": "ok", "service": "forge", "version": "0.1.0"}
""",

    "backend/app/routers/health.py": """from fastapi import APIRouter

router = APIRouter()

@router.get("/health")
async def health():
    return {"status": "healthy"}
""",

    "backend/app/requirements.txt": """fastapi==0.110.0
uvicorn==0.29.0
""",

    "README.md": """# Project generated by LLMSynthBuilder
Run:
  pip install -r backend/app/requirements.txt
  uvicorn backend.app.main:app --host 0.0.0.0 --port 8080
"""
}
'''
    # Lo insertamos despuÃ©s de los imports existentes
    lines = src.splitlines()
    insert_at = 0
    for i, line in enumerate(lines[:200]):
        if line.startswith("from ") or line.startswith("import ") or not line.strip():
            insert_at = i+1
        else:
            break
    lines.insert(insert_at, templates.strip())
    src = "\n".join(lines)

# --- Helper _ensure_str si no existe ---
if "_ensure_str(" not in src:
    src += """

def _ensure_str(x):
    try:
        from core.llm.async_utils import resolve_text
        if hasattr(x, '__await__') or getattr(x, '__class__', None).__name__ in ('coroutine',):
            x = resolve_text(x)
    except Exception:
        pass
    if isinstance(x, bytes):
        return x.decode('utf-8', 'ignore')
    return str(x)
"""

# --- Reescribir build(project_id, plan) de forma limpia y determinista ---
pattern = re.compile(r"(?ms)^def\s+build\s*\(.*?\):.*?(?=^def\s+|^class\s+|^\Z)")
new_block = r'''
def build(project_id: str, plan: dict) -> dict:
    """
    Deterministic synth builder:
    - Usa DEFAULT_TEMPLATES si plan['structure'] es corta o no existe.
    - Escribe archivos en WORKDIR_ROOT/<project_id>/...
    - Devuelve {"workdir": "...", "file_count": N}
    """
    from pathlib import Path as _P
    from core.settings import WORKDIR_ROOT

    workdir = WORKDIR_ROOT / project_id
    workdir.mkdir(parents=True, exist_ok=True)

    structure = plan.get("structure") or []
    if not isinstance(structure, list) or len(structure) < 3:
        structure = [{"path": k} for k in DEFAULT_TEMPLATES.keys()]
        plan["structure"] = structure

    count = 0
    for item in structure:
        path = (item.get("path") if isinstance(item, dict) else str(item)).strip()
        if not path:
            continue
        target = workdir / path
        target.parent.mkdir(parents=True, exist_ok=True)

        content = DEFAULT_TEMPLATES.get(path)
        if content is None:
            if path.endswith("README.md"):
                content = "# Project generated by LLMSynthBuilder\n"
            elif path.endswith(".py"):
                content = "print('hello from forge synthesizer')\n"
            elif path.endswith("requirements.txt"):
                content = "fastapi\nuvicorn\n"
            else:
                content = ""

        content = _ensure_str(content)
        target.write_text(content, encoding="utf-8")
        count += 1

    return {"workdir": str(workdir), "file_count": count}
'''

if pattern.search(src):
    src = pattern.sub(new_block.strip(), src)
else:
    if not src.endswith("\n"):
        src += "\n"
    src += "\n" + new_block.strip() + "\n"

# --- Clase wrapper LLMSynthBuilder (si no existe o para normalizar) ---
if "class LLMSynthBuilder" not in src:
    src += r'''

class LLMSynthBuilder:
    """Wrapper con API estable: build(project_id, plan) -> dict"""
    def build(self, project_id: str, plan: dict) -> dict:
        return build(project_id, plan)
'''
p.write_text(src, encoding="utf-8")
print("OK: llm_synth_builder parcheado.")
PY

echo "==> Reiniciando uvicorn en :8011"
pkill -f "uvicorn llm_driven_service:app" >/dev/null 2>&1 || true
sleep 1
nohup python -m uvicorn llm_driven_service:app --host 0.0.0.0 --port 8011 > /tmp/forge_api.log 2>&1 &
sleep 3
tail -n 20 /tmp/forge_api.log || true

echo "==> Disparando proyecto de prueba (FastAPI baseline)"
curl -s -X POST http://localhost:8011/api/projects \
  -H "Content-Type: application/json" \
  -d '{"name":"Forge Synth Deterministic","requirements":{"features":["health","docker"]}}' | python -m json.tool || true

echo "==> Ãšltimo artefacto por API"
curl -s http://localhost:8011/api/projects/diagnostics/latest-artifact | python -m json.tool || true

echo "==> Listado de ZIP (si existe)"
python - <<'PY'
from glob import glob
from zipfile import ZipFile
zips = sorted(glob("artifacts/delivery/SAAS_Forge_Project_*.zip"))
if not zips:
    print("No hay ZIP aÃºn.")
else:
    zp = zips[-1]
    print("ZIP:", zp)
    with ZipFile(zp) as z:
        for it in z.infolist():
            print(f"{it.file_size:>6}  {it.filename}")
PY
