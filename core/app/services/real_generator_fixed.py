import os
import json
import zipfile
import tempfile
from typing import Dict, Any, List
from datetime import datetime

from backend.generators.fastapi_generator import FastAPIGenerator
from backend.generators.react_generator import ReactGenerator
from backend.generators.database_generator import DatabaseGenerator

class RealProjectGenerator:
    """Generates REAL, functional projects based on AI analysis"""
    
    def __init__(self):
        self.fastapi_gen = FastAPIGenerator()
        self.react_gen = ReactGenerator()
        self.db_gen = DatabaseGenerator()
    
    def generate_complete_project(self, project_spec: Dict[str, Any]) -> Dict[str, Any]:
        """Generate a complete, functional project"""
        
        project_name = project_spec.get("name", "generated_project")
        
        try:
            # Ensure spec has required fields
            if "description" not in project_spec:
                project_spec["description"] = "Project generated by Forge SaaS AI"
            
            # Step 1: Generate backend with FastAPI
            print("🔄 Generando backend FastAPI...")
            backend_code = self.fastapi_gen.generate(project_spec)
            
            # Step 2: Generate frontend with React
            print("🔄 Generando frontend React...")
            frontend_code = self.react_gen.generate(project_spec)
            
            # Step 3: Generate database schema
            print("🔄 Generando esquema de base de datos...")
            database_code = self.db_gen.generate(project_spec)
            
            # Combine all code
            complete_project = {
                **backend_code,
                **frontend_code,
                **database_code
            }
            
            # Add project configuration files
            complete_project.update(self._generate_config_files(project_spec))
            
            print(f"✅ Proyecto generado: {len(complete_project)} archivos")
            
            return {
                "success": True,
                "project_name": project_name,
                "files": complete_project,
                "file_count": len(complete_project),
                "generated_at": datetime.now().isoformat()
            }
            
        except Exception as e:
            print(f"❌ Error generando proyecto: {e}")
            return {
                "success": False,
                "error": str(e)
            }
    
    def create_downloadable_package(self, project_data: Dict[str, Any]) -> str:
        """Create a downloadable ZIP package with the complete project"""
        
        project_name = project_data.get("project_name", "project")
        files = project_data.get("files", {})
        
        # Create temporary directory
        with tempfile.TemporaryDirectory() as temp_dir:
            project_dir = os.path.join(temp_dir, project_name)
            os.makedirs(project_dir)
            
            # Write all files
            for file_path, content in files.items():
                full_path = os.path.join(project_dir, file_path)
                
                # Create directories if needed
                os.makedirs(os.path.dirname(full_path), exist_ok=True)
                
                with open(full_path, 'w', encoding='utf-8') as f:
                    f.write(content)
            
            # Create ZIP file
            zip_path = f"/tmp/{project_name}_{datetime.now().strftime('%Y%m%d_%H%M%S')}.zip"
            with zipfile.ZipFile(zip_path, 'w') as zipf:
                for root, dirs, files_in_dir in os.walk(project_dir):
                    for file in files_in_dir:
                        file_path = os.path.join(root, file)
                        arcname = os.path.relpath(file_path, temp_dir)
                        zipf.write(file_path, arcname)
            
            return zip_path
    
    def _generate_config_files(self, project_spec: Dict[str, Any]) -> Dict[str, str]:
        """Generate configuration files for the project"""
        
        project_name = project_spec.get("name", "my_project")
        
        config_files = {}
        
        # Dockerfile
        config_files["Dockerfile"] = '''
FROM python:3.11-slim

WORKDIR /app

COPY requirements.txt .
RUN pip install --no-cache-dir -r requirements.txt

COPY . .

CMD ["uvicorn", "main:app", "--host", "0.0.0.0", "--port", "8000"]
'''
        
        # docker-compose.yml
        config_files["docker-compose.yml"] = f'''
version: '3.8'

services:
  web:
    build: .
    ports:
      - "8000:8000"
    environment:
      - DATABASE_URL=sqlite:///./test.db
    volumes:
      - .:/app
'''
        
        # README.md
        config_files["README.md"] = f'''
# {project_name.title()}

## Project Generated by Forge SaaS AI

### Description
This project was automatically generated based on your requirements.

### Quick Start

1. **Backend Setup**#!/bin/bash

echo "=== REPARANDO ERRORES PARA GENERACIÓN REAL ==="
cd /workspaces/Scouta/forge_saas

# 1. CORREGIR ERROR EN FASTAPI_GENERATOR (falta 'description')
echo -e "\n1. CORRIGIENDO FASTAPI_GENERATOR..."

# Buscar y corregir el error en fastapi_generator.py
sed -i 's/description="{spec\[.description.\]}"/description="Generated API"/g' backend/generators/fastapi_generator.py
sed -i "s/description='{spec\['description'\]}'/description='Generated API'/g" backend/generators/fastapi_generator.py

echo "✅ FastAPI Generator corregido"

# 2. CREAR SUPERVISOR_SIMPLE QUE FALTA
echo -e "\n2. CREANDO SUPERVISOR_SIMPLE..."

cat > backend/app/agents/supervisor_simple.py << 'EOF'
import logging
from datetime import datetime
from typing import Dict, Any

from core.app.agents.intake_agent import IntakeAgent
from core.app.agents.specification_agent import SpecificationAgent
from core.app.agents.planning_agent import PlanningAgent
from core.app.agents.builder_agent import BuilderAgent
from core.app.agents.documenter_agent import DocumenterAgent
from core.app.agents.tester_agent import TesterAgent

logger = logging.getLogger(__name__)

class ProjectSupervisorSimple:
    """Simplified supervisor without database dependencies"""
    
    def __init__(self):
        self.agent_sequence = [
            ("intake", "Requirements Analysis", IntakeAgent()),
            ("spec", "Specification", SpecificationAgent()),
            ("planning", "Architecture Planning", PlanningAgent()),
            ("builder", "Code Generation", BuilderAgent()),
            ("documenter", "Documentation", DocumenterAgent()),
            ("tester", "Testing", TesterAgent())
        ]
    
    def run_pipeline(self, project_id: str, requirements: dict) -> dict:
        """Execute agent pipeline without database"""
        logger.info(f"Starting pipeline for project {project_id}")
        
        results = {}
        current_requirements = requirements.copy()
        
        for agent_id, description, agent_instance in self.agent_sequence:
            try:
                logger.info(f"Running {agent_id} agent: {description}")
                
                # Execute agent
                agent_result = agent_instance.run(project_id, current_requirements)
                
                if agent_result.get("status") == "failed":
                    logger.error(f"Agent {agent_id} failed: {agent_result.get('error')}")
                    results[agent_id] = agent_result
                    break
                    
                # Store result and update requirements
                results[agent_id] = agent_result
                current_requirements.update(agent_result)
                
                logger.info(f"Completed {agent_id} agent successfully")
                
            except Exception as e:
                logger.error(f"Error in {agent_id} agent: {e}")
                results[agent_id] = {
                    "status": "failed",
                    "error": str(e)
                }
                break
        
        return {
            "project_id": project_id,
            "pipeline_status": "completed" if len(results) == len(self.agent_sequence) else "failed",
            "results": results,
            "agents_completed": list(results.keys())
        }
